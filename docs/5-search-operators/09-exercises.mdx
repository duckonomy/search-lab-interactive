import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# üëê Exercises

Time to get some practice with the concepts you've learned! Try to answer the following questions to the best of your ability. Feel free to reference the slides and notes you've taken during the lesson.

No cheating! Try to look at the answer only after you give it a try.

## Interactive Practice Exercises

Before diving into the coding exercises, practice these search operator concepts interactively:

<InteractiveExercise
  title="Fuzzy Search Challenge"
  description="Search for 'programing' (misspelled) and use fuzzy search to find programming books."
  initialQuery={`[
  {
    $search: {
      index: "fulltextsearch_dynamic",
      text: {
        query: "programing",
        path: {
          "wildcard": "*"
        },
        fuzzy: {
          maxEdits: 2
        }
      }
    }
  },
  {
    $project: {
      title: 1,
      synopsis: 1,
      score: { $meta: "searchScore" }
    }
  },
  {
    $limit: 5
  }
]`}
  expectedResult={{
    type: "minCount",
    value: 1
  }}
  hint="Use fuzzy search with maxEdits: 2 to handle the typo in 'programing'"
  solution={`[
  {
    $search: {
      index: "fulltextsearch_dynamic",
      text: {
        query: "programing",
        path: {
          "wildcard": "*"
        },
        fuzzy: {
          maxEdits: 2
        }
      }
    }
  },
  {
    $project: {
      title: 1,
      synopsis: 1,
      score: { $meta: "searchScore" }
    }
  },
  {
    $limit: 5
  }
]`}
  collection="books"
/>

<InteractiveExercise
  title="Compound Query Challenge"
  description="Create a compound query that searches for 'cooking' books AND filters for books with more than 200 pages."
  initialQuery={`[
  {
    $search: {
      index: "fulltextsearch_dynamic",
      compound: {
        must: [
          {
            text: {
              query: "cooking",
              path: {
                "wildcard": "*"
              }
            }
          },
          {
            range: {
              path: "pages",
              gt: 200
            }
          }
        ]
      }
    }
  },
  {
    $project: {
      title: 1,
      pages: 1,
      synopsis: 1,
      score: { $meta: "searchScore" }
    }
  }
]`}
  expectedResult={{
    type: "minCount",
    value: 1
  }}
  hint="Use compound.must with text and range operators"
  solution={`[
  {
    $search: {
      index: "fulltextsearch_dynamic",
      compound: {
        must: [
          {
            text: {
              query: "cooking",
              path: {
                "wildcard": "*"
              }
            }
          },
          {
            range: {
              path: "pages",
              gt: 200
            }
          }
        ]
      }
    }
  },
  {
    $project: {
      title: 1,
      pages: 1,
      synopsis: 1,
      score: { $meta: "searchScore" }
    }
  }
]`}
  collection="books"
/>

<InteractiveExercise
  title="Advanced Phrase Search"
  description="Find books with the exact phrase 'quick and easy' in their content, allowing for up to 1 word between terms."
  initialQuery={`[
  {
    $search: {
      index: "fulltextsearch_dynamic",
      phrase: {
        query: "quick and easy",
        path: {
          "wildcard": "*"
        },
        slop: 1
      }
    }
  },
  {
    $project: {
      title: 1,
      synopsis: 1,
      score: { $meta: "searchScore" }
    }
  }
]`}
  expectedResult={{
    type: "minCount",
    value: 1
  }}
  hint="Use phrase search with slop: 1 to allow flexibility in word ordering"
  solution={`[
  {
    $search: {
      index: "fulltextsearch_dynamic",
      phrase: {
        query: "quick and easy",
        path: {
          "wildcard": "*"
        },
        slop: 1
      }
    }
  },
  {
    $project: {
      title: 1,
      synopsis: 1,
      score: { $meta: "searchScore" }
    }
  }
]`}
  collection="books"
/>

## üìö Application Integration Exercises

## Add fuzzy search

Try adding fuzzy search to your application so it can find the correct books, even if the user makes a typo.

:::tip
Remember the fuzzy parameter of the [`text`](https://www.mongodb.com/docs/atlas/atlas-search/text/#std-label-text-ref) operator? This is where you'd use it.
:::


<Tabs groupId="server">
<TabItem value="node" label="üöÄ NodeJS/Express">
<details>
  <summary>Answer</summary>
  <div>

```js
public async searchBooks(query: string): Promise<Book[]> {
  const aggregationPipeline = [
      {
          $search: {
              index: 'fulltextsearch',
              text: {
                  query,
                  path: ['title', 'authors.name', 'genres'],
                  fuzzy: {
                    maxEdits: 2
                  }
              }
          }
      }
  ];
  const books = await collections?.books?.aggregate(aggregationPipeline).toArray() as Book[];
  return books;
}
```

  </div>
</details>
</TabItem>


<TabItem value="java" label="‚òïÔ∏è Java Spring Boot">
<details>
  <summary>Answer</summary>
  <div>


```java title='src/main/java/com/mongodb/devrel/library/domain/service/BookService.java'
public List<Book> searchBooks(String theTerm) {
    AggregationOperation searchStage = context -> new Document("$search",
            new Document("index", "fulltextsearch")
                    .append("text", new Document("query", theTerm)
                            .append("path", Arrays.asList("title", "authors.name", "genres"))
                            .append("fuzzy", new Document("maxEdits", 2L))));

    Aggregation aggregation = Aggregation.newAggregation(searchStage);

    return mongoTemplate.aggregate(aggregation, "books", Book.class).getMappedResults();
}
```
  </div>
</details>
</TabItem>
</Tabs>


## Promote the books of the month

The marketing team has decided that they want to promote the books of the month. They want to show these books first in the search results. How would you do this?

:::tip
You'll need to use the [`compound`](https://www.mongodb.com/docs/atlas/atlas-search/compound/#std-label-compound-ref) operator with multiple operators here. There is a `bookOfTheMonth` boolean field on some of the books that you could use.
:::
<Tabs groupId="server">
<TabItem value="node" label="üöÄ NodeJS/Express">
<details>
  <summary>Answer</summary>
  <div>

```js
public async searchBooks(query: string): Promise<Book[]> {
    const aggregationPipeline = [
        {
          $search: {
            "index": "fulltextsearch",
            "compound": {
              "must": [
                {
                  "text": {
                    query,
                    "path": ["title", "authors.name", "genres"],
                    fuzzy: {
                      maxEdits: 2
                    }
                  }
                }
              ],
              "should": [
                {
                  "equals": {
                    "value": true,
                    "path": "bookOfTheMonth",
                    "score": {
                      "boost": { value: 10 }
                    }
                  }
                }
              ]
            }
          }
        }
      ];
    const books = await collections?.books?.aggregate(aggregationPipeline).toArray() as Book[];
    return books;
}
```

  </div>
</details>
</TabItem>
<TabItem value="java" label="‚òïÔ∏è Java Spring Boot">
<details>
  <summary>Answer</summary>
  <div>
```java title='src/main/java/com/mongodb/devrel/library/domain/service/BookService.java'
public List<Book> searchBooks(String theTerm) {
    AggregationOperation searchStage = context -> new Document("$search",
        new Document("index", "fulltextsearch")
            .append("compound", new Document("must", List.of(
                new Document("text", new Document("query", theTerm)
                    .append("path", Arrays.asList("title", "authors.name", "genres"))
                    .append("fuzzy", new Document("maxEdits", 2L)))
            )).append("should", List.of(
                new Document("equals", new Document("value", true)
                    .append("path", "bookOfTheMonth")
                    .append("score", new Document("boost", new Document("value", 10L))))
            )))
    );

    Aggregation aggregation = Aggregation.newAggregation(searchStage);
    return mongoTemplate.aggregate(aggregation, "books", Book.class).getMappedResults();
}
```
  </div>
</details>
</TabItem>
</Tabs>
